# 设计规范
## 关系
数据库本身就是管理关系的，关系包括实体与实体内部之间的关系与实体与实体之间的关系。

将实体与实体的关系，反应到最终数据库表的设计上来,将关系分成三种

* 一对一
* 一对多(多对一)
* 多对多

> 所有的关系都是指表与表之间的关系

### 一对一
一对一： 一张表中的一条记录一定只能与另外一张表中的一条记录进行对应，反之亦然。

学生表： 姓名、性别、年龄、身高、体重、婚姻状况

id(P)|姓名|性别|年龄|身高|体重|婚姻状况|
--- | --- | --- | ---| ---|---| ---|
 | | | | | | |

表设计成以上这种形式：符合要求，其中姓名、性别、年龄、身高、体重属于常用数据；但婚姻属于不常用数据，但我们在查数据时经常使用 select * ，但是这些不常用数据会占用没必要的资源。

解决方法： 将常用的和不常用的信息分离存储，分成两张表

常用信息表：

id(P)|姓名|性别|年龄|身高|体重|
--- | --- | --- | ---| ---|---|

不常用信息表: 保证常用信息与不常用信息一定能够对应止，需要找一个具有唯一性（确定记录）的字段来共同连接两张表

id(P) |婚姻状况 |
--- | ---- |

> 一个常用表中的一条记录，永远只能在一张不常用表中匹配一条记录，反过来，一个不常用表中的一条记录在常用表中也只能匹配一条常用记录，这就是一对一的关系。

### 一对多（多对一）
一对多： 一张表中有一条记录可以对应另外一张表中的多条记录，但是，另外一张表的一条记录只能对应第一张表的一条记录，这种关系就是一对多（多对一）

母亲与孩子的关系

妈妈表：

id(P)|名字|年龄|性别
--- | --- | --- | ---

孩子表：

id(P) | 名字 | 年龄 | 性别 
--- | --- | ---- | ---|

以上关系：一个妈妈可以在孩子表中找到多条记录（也有可能是一条），但一个孩子只能找到一个妈妈。

以上设计解决了实体的设计表问题，但是没有解决关系的问题：孩子找不到妈妈，妈妈也找不到孩子。

解决方案： 在某一张表中，增加一个字段能够去找到另外一张表中的记录：在孩子表中增加一个字段指向妈妈表，因为孩子表的记录只能匹配到一条妈妈表的记录，（多表中增加一个字段指向单表）如下：

妈妈表：

id(P)|名字|年龄|性别
--- | --- | --- | ---

孩子表：

id(P) | 名字 | 年龄 | 性别 | 妈妈ID
--- | --- | ---- | ---| --- |
  | | | | | 妈妈表主键|

### 多对多
多对多： 一张表中(A)的一条记录能够对应另外一张表(B)中的多条记录，同时 B 表中的一条记录也能对应 A 表中的多条记录： 多对多的关系

老师教学： 老师和学生

老师表：

T_ID(P) | 姓名 | 性别
--- | --- | ---
1 | A | 男
2 | B | 女

学生表：

S_ID(P) | 姓名 | 性别
--- | --- | ---
1 | 张三 |男
2 | 小芳 |女

以上设计方案：实现了实体的设计，但是没有维护实体的关系

一个老师教过多个学生；一个学生也被多个老师教过。

解决方案： 在学生表中增加老师字段: 不管在哪张表中增加字段，都会出现一个问题：该字段要保存多个数据，而且是与其他表有关系的的字段，不符合表的设计规范，这时个需要增加一张新表，用来专门维护两张表之间的关系。如下：


老师表：

T_ID(P) | 姓名 | 性别
--- | --- | ---
1 | A | 男
2 | B | 女

学生表：

S_ID(P) | 姓名 | 性别
--- | --- | ---
1 | 张三 |男
2 | 小芳 |女

中间关系表： 老师与学生的关系

ID|T_ID(老师) | S_ID(学生)
--- |--- | ---
1 | 1 | 1
2 | 1 | 2
3 | 2 | 1

增加中间表之后： 中间表与老师表形成一对多的关系，而且中间表是多表,维护了能够唯一找到一表的关系。同样学生表与中间表也是一个一对多的关系，一对多的关系可以匹配到关联表之间的数据。

学生找老师：找出学生id -> 中间表寻找匹配记录（多条） -> 老师表匹配（一条)
老师找学生：找出老师id -> 中间表寻找匹配记录（多条） -> 学生表匹配（一条)


## 范式
范式： Normal Format,它是一种离散数学中的知识,是为了解决一种数据的存储与优化的问题，保证数据存储之后，凡是能够通过关系寻找出来的数据，坚决不再重复存储；终极目标是为了减少数据的冗余存储

它是一种分层结构的规范，分为6层，每一层都比上一层更加严格，若要满足下一层范式，前提是满足上一层范式。

六层范式： 1NF, 2NF, 3NF, 4NF, 5NF, 6NF,层级越来越严格

MySQL属于关系型数据库，它有空间浪费，也是致力于节省存储空间，与范式解决的问题不谋而合，所以在设计数据库时，会利用范式来指导设计，但是数据库不单是要解决空间问题，还要保证效率问题；而范式只解决空间问题，所以数据库的设计又不可能完全按照范式的要求实现：一般情况下，只有前三种范式需要满足。

范式在数据库的设计当中是有指导意义，但是不是强制规范。

### 1NF
1NF: 在设计表存储数据的时候，如果表中设计的字段存储的数据在取出来使用之间还需要额外的处理（拆分），那么表的设计不满足第一范式，第一范式要求字段的数据具有原子性，不可再分。

讲师 | 性别 | 班级 | 教室 | 代课时间 | 代课时间(开始，结束)
--- | --- | --- | --- | --- | --- 
朱元璋 | Male | 0225 | D302 | 30天 | 2014-43-43,2017-03-89
李世民 | Male | 0225 | D302 | 30天 | 2014-43-43,2017-03-89
朱元璋 | Male | 0225 | D302 | 30天 | 2014-43-43,2017-03-89

上表设计不存问题，但是需求是将数据查出来之后，要求显示一个老师从什么时候开始上课到什么时候结课，这时候需要将代课时间进行拆分，这时它就不符合 1NF，因为还可以再拆分

解决方案： 将代课时间拆分成两个字段就解决问题了，如下：

讲师 | 性别 | 班级 | 教室 | 代课时间 | 开课时间 | 结课时间
--- | --- | --- | --- | --- | --- |--- 
朱元璋 | Male | 0225 | D302 | 30天 | 2014-43-43|2017-03-89
李世民 | Male | 0225 | D302 | 30天 | 2014-43-43|2017-03-89
朱元璋 | Male | 0225 | D302 | 30天 | 2014-43-43|2017-03-89


### 2NF
2NF: 在数据表设计的过程中，如果有复合主键（多字段主键），且表中有字段并不是由整个主键来确定，而是依赖主键中的某个字段（主键的部分）；存在字段依赖主键部分的问题，称之为部分依赖；第二范式就是要解决表设计不允许出现部分依赖。

讲师带课表

讲师 | 性别 | 班级 | 教室 | 代课时间 | 代课时间(开始，结束)
--- | --- | --- | --- | --- | --- 
朱元璋 | Male | 0225 | D302 | 30天 | 2014-43-43,2017-03-89
李世民 | Male | 0225 | D302 | 30天 | 2014-43-43,2017-03-89
朱元璋 | Male | 0225 | D302 | 30天 | 2014-43-43,2017-03-89

以上表中：因为讲师没有办法作为独立主键，需要结合班级才能作为主键（复合主键：一个老师在一个班永远只带一个阶段的课）；代课时间开始和结束字段都与当前代课主键（讲师和班级）有关，但是性别并不依赖班级，同时教室不依赖讲师，并且性别只依赖讲师，教室只依赖班级，这时候就出现了性别和教室依赖主键中的一部分，部分依赖，不符合第二范式。

解决方案：

1. 将性别与讲师单独成表，同时班级与教室单独成表
2. 取消复合主键，使用逻辑主键，如下：

ID(P)|讲师 | 性别 | 班级 | 教室 | 代课时间 | 开课时间 | 结课时间
--- | ---| --- | --- | --- | --- | --- |--- 
1 | 朱元璋 | Male | 0225 | D302 | 30天 | 2014-43-43|2017-03-89
2 | 李世民 | Male | 0225 | D302 | 30天 | 2014-43-43|2017-03-89
3 | 朱元璋 | Male | 0225 | D302 | 30天 | 2014-43-43|2017-03-89

> ID = 讲师 + 班级

逻辑主键理论上没有任何意义，只能代表记录有唯一性，上面例子中，逻辑主键并不能确保班级和讲师不重复，这时候可以使用复合唯一键或业务逻辑来约束。

### 3NF
要满足第三范式，必须满足前两范式。

3NF: 理论上讲，一张表中的所有字段都应该直接依赖主键（逻辑主键除外:代表的是业务主键）, 如果表设计中存在一个字段，并不直接依赖主键，而是通过某个非主键字段依赖，最终实现依赖主键，把这种不是直接依赖主键，而是依赖非主键字段的依赖关系称之为传递依赖。第三范式就是要解决传递依赖的问题。

讲师带课表

ID(P)|讲师 | 性别 | 班级 | 教室 | 代课时间 | 开课时间 | 结课时间
--- | ---| --- | --- | --- | --- | --- |--- 
1 | 朱元璋 | Male | 0225 | D302 | 30天 | 2014-43-43|2017-03-89
2 | 李世民 | Male | 0225 | D302 | 30天 | 2014-43-43|2017-03-89
3 | 朱元璋 | Male | 0225 | D302 | 30天 | 2014-43-43|2017-03-89

以上设计方案中，性别依赖讲师存在，讲师依赖主键；教室依赖班级，班级依赖主键；性别和教室都存在传递依赖。

解决方案： 将存在传递依赖的字段，以及依赖的字段本身单独取出，形成一个单独的表，然后在需要对应的信息的时候，使用对应的实体表的主键加进来.

ID(P)|讲师ID | 班级ID |  代课时间 | 开课时间 | 结课时间
--- | ---| --- |  --- | --- |--- 
1 | 1 | 10 | 30天 | 2014-43-43|2017-03-89
2 | 1 | 12 | 30天 | 2014-43-43|2017-03-89
3 | 2 | 12 | 30天 | 2014-43-43|2017-03-89

讲师表:

ID | 讲师 | 性别 
--- | ---| --- | --- | --- | --- | --- |--- 
1 | 朱元璋 | male
2 | 李世民 | male
讲师表中: ID = 讲师

班级表：

ID | 班级 | 教室
--- | ---| --- | --- | --- | --- | --- |--- 
10 | 0226 | 302
12 | 0320 | 206
班级表中： ID=班级

> 当某个字段在一张表里面会出现多次时，一般会采用这种映射的关系，这样可以去除数据表的冗余字段(会使得查对应的东西必须联合查询)，但也有例外，如下

### 逆规范化
有时候在设计表的时候，如果一张表中有几个字段是需要从另外的表中去获取信息，理论上讲，的确可以获取到想要的数据，但是就是效率低一点，会刻意在某些表中不去保存另外表的主键（逻辑主键），而是直接保存想要的数据信息，这样，在查询数据的时候，一张表可以直接提供数据，而不需要多表查询（效率低）,但是会导致数据冗余增加。

逆规范化：磁盘利用率与效率的对抗。

