# 设计规范
## 关系
数据库本身就是管理关系的，关系包括实体与实体内部之间的关系与实体与实体之间的关系。

将实体与实体的关系，反应到最终数据库表的设计上来,将关系分成三种

* 一对一
* 一对多(多对一)
* 多对多

> 所有的关系都是指表与表之间的关系

### 一对一
一对一： 一张表中的一条记录一定只能与另外一张表中的一条记录进行对应，反之亦然。

学生表： 姓名、性别、年龄、身高、体重、婚姻状况

id(P)|姓名|性别|年龄|身高|体重|婚姻状况|
--- | --- | --- | ---| ---|---| ---|
 | | | | | | |

表设计成以上这种形式：符合要求，其中姓名、性别、年龄、身高、体重属于常用数据；但婚姻属于不常用数据，但我们在查数据时经常使用 select * ，但是这些不常用数据会占用没必要的资源。

解决方法： 将常用的和不常用的信息分离存储，分成两张表

常用信息表：
id(P)|姓名|性别|年龄|身高|体重|
--- | --- | --- | ---| ---|---|

不常用信息表: 保证常用信息与不常用信息一定能够对应止，需要找一个具有唯一性（确定记录）的字段来共同连接两张表
id(P) |婚姻状况 |
--- | ---- |

> 一个常用表中的一条记录，永远只能在一张不常用表中匹配一条记录，反过来，一个不常用表中的一条记录在常用表中也只能匹配一条常用记录，这就是一对一的关系。

### 一对多（多对一）
一对多： 一张表中有一条记录可以对应另外一张表中的多条记录，但是，另外一张表的一条记录只能对应第一张表的一条记录，这种关系就是一对多（多对一）

母亲与孩子的关系

妈妈表：
id(P)|名字|年龄|性别
--- | --- | --- | ---

孩子表：
id(P) | 名字 | 年龄 | 性别 
--- | --- | ---- | ---|

以上关系：一个妈妈可以在孩子表中找到多条记录（也有可能是一条），但一个孩子只能找到一个妈妈。

以上设计解决了实体的设计表问题，但是没有解决关系的问题：孩子找不到妈妈，妈妈也找不到孩子。

解决方案： 在某一张表中，增加一个字段能够去找到另外一张表中的记录：在孩子表中增加一个字段指向妈妈表，因为孩子表的记录只能匹配到一条妈妈表的记录，如下：

妈妈表：
id(P)|名字|年龄|性别
--- | --- | --- | ---

孩子表：
id(P) | 名字 | 年龄 | 性别 | 妈妈ID
--- | --- | ---- | ---| --- |
  | | | | | 妈妈表主键|

### 多对多
多对多： 一张表中(A)的一条记录能够对应另外一张表(B)中的多条记录，同时 B 表中的一条记录也能对应 A 表中的多条记录： 多对多的关系

老师教学： 老师和学生

老师表：

T_ID(P) | 姓名 | 性别
--- | --- | ---
1 | A | 男
2 | B | 女

学生表：

S_ID(P) | 姓名 | 性别
--- | --- | ---
1 | 张三 |男
2 | 小芳 |女

以上设计方案：实现了实体的设计，但是没有维护实体的关系

一个老师教过多个学生；一个学生也被多个老师教过。

解决方案： 在学生表中增加老师字段，




